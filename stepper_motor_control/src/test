#include <Arduino.h>

// define motor connections
#define DIR_PIN 2
#define STEP_PIN 3

#include <LiquidCrystal_I2C.h>
#include <Keypad.h>
#include <FastLED.h>

#define I2C_ADDR 0x27
#define LCD_COLUMNS 20
#define LCD_LINES 2

LiquidCrystal_I2C lcd(I2C_ADDR, LCD_COLUMNS, LCD_LINES);

const uint8_t ROWS = 4;
const uint8_t COLS = 4;

char keys[ROWS][COLS] = {
{'1', '2', '3', 'A'},
{'4', '5', '6', 'B'},
{'7', '8', '9', 'C'},
{'\*', '0', '#', 'D'}};

uint8_t rowPins[ROWS] = {26, 22, 21, 20}; // Pins connected to R1, R2, R3, R4
uint8_t colPins[COLS] = {19, 18, 17, 16}; // Pins connected to C1, C2, C3, C4

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

int direction = 1; // cw or ccw --> 1 or -1
float distance = 0; // input in (mm)
float velocity = 100; // velocity in (mm/s)
float accel = 400; // acceleration in (mm/s^2)

// convert to steps
float velocity_steps_s = 0;
float accel_steps_s2 = 0;
int distance_steps = 0;
int current_postion_steps = 0;

// prev state
int prev_direction = 0;
float prev_distance = 0;
float prev_velocity = 0;
float prev_accel = 0;

// define constants
// Stepper motor specifications
const int SPR = 200; // Steps per revolution
const float pitch = 8.0; // Pitch (mm per revolution)
const int microsteps = 1; // Microsteps per step

// motion type profile
// 0: trapezoidal
// 1: triangular
int motionProfileType = 0; // default is trapezoidal

// Motor state
int currentPosition = 0;
unsigned long startTime = 0;
unsigned long endTime = 0;
bool motorStartFlag = false;

//========== PRINT OPERATOR =============
template <class T>
inline Print &operator<<(Print &obj, T arg)
{
obj.print(arg);
return obj;
}

template <>
inline Print &operator<<(Print &obj, float arg)
{
obj.print(arg, 4);
return obj;
}

// these functions will convert user input given mm/s, mm/s^2, and mm --> steps/s, steps/s^2, and steps

// convert velocity from mm/s --> microsteps/s
float convertVelocity(float velocity, int SPR, float pitch, int microsteps)
{
return (velocity _ SPR _ microsteps) / pitch;
}

// convert acceleration from mm/s^2 --> microsteps/s^2
float convertAcceleration(float accel, int SPR, float pitch, int microsteps)
{
return (accel _ SPR _ microsteps) / pitch;
}

// convert distance from mm --> microsteps
int convertDistance(float distance, int SPR, float pitch, int microsteps)
{
return (int)((distance _ SPR _ microsteps) / pitch);
}

// convert steps --> mm
float convertStepsToMM(int steps, int microsteps, int SPR, float pitch)
{
return (steps _ pitch) / (microsteps _ SPR);
}

void moveSteps(int direction, int microsteps, float velocity, float acceleration)
{
digitalWrite(DIR_PIN, direction == 1 ? HIGH : LOW);

// Calculate acceleration time
float accelTime = velocity / acceleration;

// Calculate total time for acceleration and deceleration
float totalTime = 2 \* accelTime;

// Calculate microstep delay for one step
int microstepDelay = (int)((totalTime / 2) \* 1e6) / microsteps;

digitalWrite(STEP_PIN, HIGH);
delayMicroseconds(microstepDelay);
digitalWrite(STEP_PIN, LOW);
delayMicroseconds(microstepDelay);
}

void moveStepperTrapezoidal(int currentPosition, int targetPosition, int direction)
{
// calculate distance to move
int distance_in_steps = abs(targetPosition - currentPosition);
Serial << "distance: " << distance_in_steps << "\n";

// calculate steps for acceleration & deceleration
int accelSteps = (int)(velocity_steps_s _ velocity_steps_s / (2 _ accel_steps_s2));
int decelSteps = accelSteps;

// check if total distance is less than total accel/decel steps
// triangle profile
if (distance_in_steps < (accelSteps + decelSteps))
{
// need to adjust velocity to avoid overshooting
velocity_steps_s = sqrt(2 _ accel_steps_s2 _ distance_in_steps / 2);
accelSteps = (int)(velocity_steps_s _ velocity_steps_s / (2 _ accel_steps_s2));
decelSteps = accelSteps;
}

// trapzoidal profile
// acceleration phase
for (int steps = 0; steps < accelSteps; steps++)
{
moveSteps(direction, microsteps, velocity_steps_s, accel_steps_s2);
}

// constant velocity phase
int constantSpeedSteps = distance_in_steps - 2 \* accelSteps;
for (int steps = 0; steps < constantSpeedSteps; steps++)
{
moveSteps(direction, microsteps, velocity_steps_s, accel_steps_s2);
}

// deceleration phase
for (int steps = 0; steps < decelSteps; steps++)
{
moveSteps(direction, microsteps, velocity_steps_s, accel_steps_s2);
}
}

// determine the type of motion profile --> Trapezoidal or triangular
int determineMotionProfileType(float maxVelocity, float distance, float maxAcceleration)
{
// v = u + at --> t = (v - u) / a : u = 0
float accelerationTime = maxVelocity / maxAcceleration;

// s = ut + 1/2 at^2 : u = 0
float accelerationDistance = 0.5 _ maxAcceleration _ accelerationTime _ accelerationTime;
// acceleration & deceleration are the same
float constantVelocityDistance = distance - 2 _ accelerationDistance;

if (constantVelocityDistance > 0)
{
// There is a constant velocity phase --> trapezoidal
return 0;
}
else
{
// There is no constant velocity phase --> triangular
return 1;
}
}

// set up
void setup()
{
// init
lcd.init();
lcd.backlight();

// pins for motor
pinMode(STEP_PIN, OUTPUT);
pinMode(DIR_PIN, OUTPUT);

// print something
// lcd.setCursor(3, 0);
// lcd.print("Hello, world!");

// recalculate the motion profile
motionProfileType = determineMotionProfileType(velocity, distance, accel);
}

int getInput(const char *context, const char *unit)
{
String inputString = "";

lcd.clear();
lcd.setCursor(0, 0);
lcd.print("Enter ");
lcd.print(context);
lcd.setCursor(0, 1);
lcd.print("(in ");
lcd.print(unit);
lcd.print("):");

while (true)
{
char key = keypad.getKey();

    if (key)
    {
      if (isdigit(key))
      {
        inputString += key;
        lcd.print(key);
      }
      else if (key == '*')
      {
        break;
      }
      else if (key == 'C')
      {
        inputString = ""; // Clear the input on 'C' key press
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print("Enter ");
        lcd.print(context);
        lcd.setCursor(0, 1);
        lcd.print("(in ");
        lcd.print(unit);
        lcd.print("):");
      }
    }

}

int inputValue = inputString.toInt();

// be very careful with comparing string --> if input changes, this will break
if (context == "Velocity")
{
if (inputValue > 100)
{
inputValue = 100;
}
}

// be very careful with comparing string
if (context == "Acceleration")
{
if (inputValue > 400)
{
inputValue = 400;
}
}

// TODO: check what is the context and limit the value
lcd.clear();
lcd.setCursor(0, 0);
lcd.print(context);
lcd.setCursor(0, 1);
lcd.print("Value: ");
lcd.print(inputValue);
lcd.print(" ");
lcd.print(unit);

delay(1000); // dispaly for 1 second

return inputValue;
}

// loop
void loop()
{

char key = keypad.getKey();

if (key != NO_KEY)
{
switch (key)
{
// this is for direction
case 'A':
lcd.clear();
lcd.setCursor(0, 0);
lcd.print("Set Direction:");
prev_direction = direction;
direction = 1;
lcd.setCursor(2, 1);
lcd.print("CW");
delay(500);
break;
case 'B':
lcd.clear();
lcd.setCursor(0, 0);
lcd.print("Set Direction:");
prev_direction = direction;
direction = -1;
lcd.setCursor(2, 1);
lcd.print("CCW");
delay(500);
break;
case '1':
// this is for velocity
prev_velocity = velocity;
velocity = getInput("Velocity", "mm/s");
if (velocity >= 100)
{
velocity = 100;
}
break;
case '2':
// take distance input
prev_distance = distance;
distance = getInput("Distance", "mm");
break;
case '3':
// take acceleration input
prev_accel = accel;
accel = getInput("Acceleration", "mm/s^2");
if (accel > 400)
{
accel = 400;
}
break;
case '#':
// Start the motor
lcd.clear();
if (motorStartFlag == false)
{
motorStartFlag = true;
}
break;
}
}

if (motorStartFlag)
{
Serial << "Start moving\n";
startTime = millis(); // Record the start time
moveStepperTrapezoidal(currentPosition, currentPosition + convertDistance(distance, SPR, pitch, microsteps), direction);
endTime = millis(); // Record the end time
currentPosition += direction \* convertDistance(distance, SPR, pitch, microsteps); // Update the current position
motorStartFlag = false; // Reset the flag
Serial << "Stop moving\n";
}

// print the input
if (prev_direction != direction || prev_distance != distance || prev_velocity != velocity || prev_accel != accel)
{
// recalculate the motion profile
motionProfileType = determineMotionProfileType(velocity, distance, accel);
Serial << "Motion Profile Type: " << motionProfileType << "\n";

    // Convert inputs to steps
    velocity_steps_s = convertVelocity(velocity, SPR, pitch, microsteps);
    accel_steps_s2 = convertAcceleration(accel, SPR, pitch, microsteps);
    distance_steps = convertDistance(distance, SPR, pitch, microsteps);

    // Print the intputs
    Serial << "velocity_steps_s: " << velocity_steps_s << " accel_steps_s2: " << accel_steps_s2 << " distance_steps: " << distance_steps << "\n";

    prev_direction = direction;
    prev_distance = distance;
    prev_velocity = velocity;
    prev_accel = accel;

}

// clear after getting user input
// lcd.clear();

lcd.setCursor(0, 0);
lcd.print("Position:");
lcd.print(convertStepsToMM(currentPosition, microsteps, SPR, pitch));
lcd.print(" mm");
lcd.setCursor(0, 1);
lcd.print("Time:");
lcd.print((endTime - startTime) / 1000.0);
lcd.print(" s");
}
